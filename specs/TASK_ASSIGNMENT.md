# 翻譯任務分配與分批規格

本文檔闡述了 `laradoc-trans` 專案中，如何將一篇完整的 Markdown 文件切割成多個適合語言模型 (LLM) 處理的「任務 (Task)」的核心設計思想與實現細節。

## 1. 核心概念定義

在深入了解分配策略之前，必須先理解兩個核心的物件：`Section` 和 `Task`。

### 1.1. `Section` (章節)

`Section` 是構成一篇文件的最基本單位。它代表了文件中的一個標題及其對應的內容。

- **來源**: `markdownParser.ts` 中的 `splitMarkdownIntoSections` 函式負責將原始 Markdown 純文字解析成一個 `Section[]` 一維陣列。
- **結構**: 雖然被儲存在一維陣列中，但每個 `Section` 物件都透過以下屬性保留了其在原始文件中的結構資訊：
  - `title`: 標題文字。
  - `depth`: 標題深度（例如，`#` 為 1，`##` 為 2）。
  - `parent`: 指向其父 `Section` 物件的參考，形成了邏輯上的樹狀結構。
- **大小**: 每個 `Section` 有兩個關於大小的關鍵屬性：
  - `contentLength`: **物理大小**。代表該 `Section` **自身**的內容（**包含標題行**）的實際位元組數。
  - `totalLength`: **邏輯大小**。代表該 `Section` 的 `contentLength` **加上其所有後代 `Section` 的 `contentLength` 之和**。這個值被用來評估一個邏輯區塊的整體規模。

### 1.2. `Task` (任務)

`Task` 代表一個準備發送給 LLM 進行翻譯的具體工作單元。它由一個或多個 `Section` 組成。

- **目的**: 將多個小的 `Section` 組合成一個較大的 `Task`，以達到 API 請求的經濟效益。
- **上下文感知 (Context-Aware)**: `Task` 可以被指定一個 `parentContext` (父章節)。這在「拆分模式」下至關重要，用於告知處理流程，雖然這個 `Task` 的內容不完整，但它邏輯上隸屬於某個更大的父章節，確保了測試驗證時的結構完整性。
- **容量限制**: 一個 `Task` 的內容總量不應超過一個預設的上限 (`BATCH_SIZE_LIMIT`)，定義於 `src/translator/Task.ts`。
- **簡化的 `addSection`**: `Task.addSection` 方法現在只負責將 `Section` 加入任務並更新其內部計數，**不包含任何複雜的打包決策邏輯**。
- **工廠建立**: 為了確保任務 ID 在處理多個檔案時能被正確管理，`Task` 物件不應直接被實例化，而是應透過 `TaskFactory` 來建立。

---

## 2. 核心挑戰

1.  **LLM 輸出中斷**：單次請求內容過長，可能導致 LLM 在未達到理論 Token 上限時無預警地中斷輸出。
2.  **上下文破碎 (Context Fragmentation)**：在拆分巨大章節時，如果隨意拆分，可能會將一個子標題 (`#### H4`) 與其父標題 (`### H3`) 分到不同的任務中，導致 LLM 翻譯時因缺乏上下文而產生幻覺或錯誤。
3.  **邏輯層級混亂**：在打包多個章節時，若將一個高級別標題（如 H1）附加到一個已經由低級別標題（如 H2）開始的任務中，會造成文件結構的邏輯混亂。

---

## 3. 設計總覽：三情境打包與拆分模式

為了解決上述挑戰，`assignTasks` 函式採用了一套精密的打包策略。其核心是將文件流視為一系列的「章節群組 (Group)」，並根據群組的大小和當前任務的狀態，決定如何處理它。

### 3.1. 序言優先處理 (Preamble First)

在進入主迴圈、進行大規模的併發翻譯任務之前，程式會執行一個至關重要的前置步驟：「序言優先」策略。

1.  **獨立分配**: 程式會檢查文件的第一個章節 (`allSections[0]`)。如果它是一個頂層章節（深度為 1，通常是包含目錄的 H1 或文件序言），它會被立即分配到一個獨立的、專屬的 `Task` 中。

2.  **串行翻譯，建立基準**: 這個序言任務**不會**與其他任務並行執行。程式會優先、且獨立地完成這個任務的翻譯。其目的是為了先取得一份包含文章目錄（TOC）的、翻譯完成的「基準」版本。

3.  **注入上下文，確保一致性**: 在序言翻譯完成後，才會開始併發處理剩餘的所有任務。在處理這些後續任務時，程式會將先前翻譯好的「序言基準」作為額外的上下文資訊提供給 LLM，並明確指示模型：「在翻譯新的章節標題時，必須確保其翻譯結果與這份基準序言中的目錄標題完全一致」。

這個策略雖然犧牲了完全的並行性，但它從根本上解決了因分批翻譯而可能導致的標題不一致問題，是確保整份文件翻譯品質與連結準確性的核心機制。

### 3.2. 章節群組 (Group)

在進入主迴圈後，程式的第一步是定義「群組」。一個群組由一個起始章節（如 H2）及其所有後代章節（H3, H4...）組成，直到遇到下一個同級或更高級別的章節為止。這個群組代表了一個完整的、邏輯獨立的內容單元。

### 3.3. 打包與拆分的三種情境

對於每一個識別出來的「群組」，程式會根據以下三種情境進行處理：

1.  **情境一：能裝入當前任務 (Fits in Current Task)**
    - **條件**: `當前任務內容` + `群組內容` <= `BATCH_SIZE_LIMIT`。
    - **動作**: 直接將該群組的所有章節加入當前任務。
    - **額外規則**: 在加入前，會進行「層級檢查」。

2.  **情境二：能裝入新任務 (Fits in New Task)**
    - **條件**: 不滿足情境一，但 `群組內容` <= `BATCH_SIZE_LIMIT`。
    - **動作**: 將當前任務結束並儲存，然後建立一個全新的任務，並將該群組完整地加入這個新任務。

3.  **情境三：群組過大，必須拆分 (Splitting Mode)**
    - **條件**: `群組內容` > `BATCH_SIZE_LIMIT`。
    - **動作**: 觸發「拆分模式」，對這個巨大群組進行內部再切分。

---

## 4. 核心規則詳解

### 4.1. 層級檢查規則 (Heading Level Constraint)

此規則在**情境一**中觸發，是為了防止邏輯混亂。

- **規則**: 不允許在一個任務中，加入比該任務**第一個章節**層級更「高」的章節（層級數值更小）。
- **舉例**: 如果一個 `Task` 的第一個章節是 H3 (`depth: 3`)，那麼任何以 H1 (`depth: 1`) 或 H2 (`depth: 2`) 開頭的新群組都不能被加入這個 `Task`。如果發生這種情況，將會強制結束當前任務，為這個新群組開啟一個新任務（行為類似情境二）。

### 4.2. 拆分模式詳解 (Splitting Mode)

此模式在**情境三**中觸發，是為了處理像 `dusk.md` 這樣的巨大文件，同時避免上下文破碎。

1.  **結束當前任務**: 如果當前任務有內容，先將其儲存。
2.  **設定父上下文**: 建立一個新任務，並將這個巨大群組的起始章節（通常是 H2 標頭）設定為 `parentContext`。這個設定對於後續的測試驗證至關重要。

3.  **單獨處理群組標頭**: 將巨大群組的起始章節（H2 標頭本身）先單獨放入新任務中。

4.  **內部再分組**: 從巨大群組的第二個章節（即 H2 的第一個子章節）開始遍歷，並再次應用「群組」邏輯，但這次是在 H3 或更低的層級上形成「子群組」。

5.  **打包子群組**: 將這些「子群組」逐一嘗試放入當前任務。如果放不下，就結束當前任務，建立一個新的、同樣帶有 `parentContext` 的任務，再將子群組放入。

6.  **處理巨大子群組**: 根據規則，如果一個「子群組」（例如一個 H3 及其所有後代）本身就超過 `BATCH_SIZE_LIMIT`，我們不再對其進行更深層次的遞迴拆分。而是直接將這個巨大的子群組完整地放入一個全新的、帶有 `parentContext` 的任務中。

---

## 5. 虛擬碼 (Pseudocode)

```pseudocode
function assignTasks(allSections):
    // ... 序言處理 ...
    let currentTask = createTask()

    for each section starting from index 1:
        // 1. 建立一個包含後代的章節群組 (group)
        group = createGroupFrom(section)

        // 2. 判斷屬於何種情境
        fitsInCurrent = currentTask.length + group.length <= LIMIT
        fitsInNew = group.length <= LIMIT

        if fitsInCurrent:
            // **情境一**
            // 檢查層級規則 (group.startDepth < currentTask.startDepth)
            if constraintViolated:
                // 規則衝突，轉為情境二處理
                finalizeAndCreateNewTaskFor(group)
            else:
                // 正常加入
                currentTask.add(group)
        else if fitsInNew:
            // **情境二**
            finalizeAndCreateNewTaskFor(group)
        else:
            // **情境三：拆分模式**
            finalizeAndStartNewTaskWithContext(group[0])
            
            // 單獨處理群組標頭
            currentTask.add(group[0])

            // 從子章節開始，進行內部再分組和打包
            for each childSection in group (from index 1):
                subGroup = createGroupFrom(childSection)
                if currentTask.length + subGroup.length > LIMIT:
                    finalizeAndStartNewTaskWithContext(group[0])
                
                // 即使 subGroup > LIMIT，也直接加入，形成獨立大任務
                currentTask.add(subGroup)
```

這個經過多次迭代的複雜邏輯，最終確保了在處理各種型別的 Markdown 文件時，任務分配都能兼顧`效能`、`上下文完整性`和`結構邏輯正確性`。

## 6. 總結：一維化與多階段迭代設計的核心優勢

本專案的最終設計，其精髓與穩健性根植於一個核心原則：**先將巢狀的樹狀結構「降維」成線性的陣列，再透過一個多階段的迭代器對其進行精密的處理**。

雖然我們最初的目標是追求極致的簡潔（例如用一個簡單的 `for` 迴圈處理所有事情），但在實踐中我們發現，為了應對巨大章節的拆分、同時保證上下文的連貫性，必須引入更複雜的處理邏輯。

最終確立的「一維 `Section` 陣列」加上「多情境打包器」的設計，其優勢在於：

1.  **基礎模型的簡潔性**：`markdownParser.ts` 將文件攤平成 `Section[]` 陣列，這一步極大地簡化了問題的基礎模型。它預先處理了所有父子關係和尺寸計算，為後續的複雜分批提供了乾淨、標準化的輸入。

2.  **職責的精準分離**：
    *   `markdownParser.ts` 專注於扮演「結構專家」。
    *   `taskAssigner.ts` 則作為一個「分批策略家」。它雖然內部邏輯複雜（包含三種打包情境和一個帶有內迴圈的拆分模式），但它面對的仍然是一個清晰的一維陣列，使其可以完全專注於實現分批的商業邏輯，而無需關心任何 Markdown 的語法細節。

3.  **兼顧穩健性與可控性**：我們最終的 `taskAssigner.ts` 雖然不再是「單純的 `for` 迴圈」，但它是一個高度結構化的、可預測的迭代演算法。它透過明確的 `if/else` 分支處理不同的打包情境，並在需要時才進入層次化的「拆分模式」。這種設計雖然複雜，但避免了直接操作 AST 可能導致的、難以追蹤的遞迴問題，在穩健性和邏輯複雜度之間取得了一個理想的平衡。

這種「先降維，再分階段精細處理」的思維，是整個系統得以保持穩健、可擴展且易於理解的根本原因。